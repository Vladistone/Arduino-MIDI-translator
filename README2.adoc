[#Back-to-Top""]
= Arduino MIDI translator
Vladistone <vl2guitar@gmail.com>
:toc:
:toclevels: 3
:doctype: book
:sectnums:
:partnums:
:sectnumlevels: 3
:experimental:
:tip-caption: pass:[&#128161;]
:warning-caption: pass:[&#9888;]
:note-caption: pass:[&#128204;]
:caution-caption: pass:[&#8252;]
:synth_upgrade_instruction: to be created as soos as possible
:code_implement_instruction: to be created as soos as possible
:readme_content: at this moment I’m just gathering my thoughts and the description of README2 is still in its starting state, as soon as possible I will add blocks and pictures of examples of both synthesizers and analysis of the code and its internal blocks with explanations

|===
|Last update of text: |`2023-12-09 (v0.01.0)`
|Last update of relevant screenshots: |`2023-12-09 (v0.01.0)`
|===

kbd:[<<Back-to-Top>>]

= Quick start

Here's a step-by-step guide to help you get started with Arduino and a MIDI controller:

. Download & Start Arduino IDE.
. If you haven't already done it, https://www.arduino.cc/en/software[install Arduino IDE].
. Make sure your MIDI_library.h is enabled in _Sketch → Include Library… → Manage Librarys ⇧⌘i →  download the MIDI_library.h if you need...
  * For the Arduino board device, tick _for your name device_ and tick
 your _Port for connection_.

kbd:[<<Back-to-Top>>]

[colophon]
= Introduction and a bit history

[TIP]
The great idea is to organize a repository for codes of `Arduino MIDI translator` in one place, which to accumulate projects related to the rare synths from 80-90 y., by Arduino upgrading to facilitate focused share knowledge, and foster collaboration among musicians & coder enthusiasts. May be this dedicated space will serve as a hub for users to exchange code mapping, ideas, troubleshoot, and showcase their projects or branching related to the any synths upgrade by Arduino,.. Time will show...


:MIDI_code_preset_content: There are many controllers projects for synth manipulation by Arduino chipping.
And although technically possible in exactly the same way as with controller presets for factory MIDI devices,
Synth map layouts and using controllers to combine with synths are very custom, so I'm no sure yet if it would make much sense to create map presets of code... but the base approach of the system for developing code for `Arduino MIDI translator` and consistency in adapting MIDI implementation has already been launched and this requires publicity...
*show must go on*!

.MIDI implementaion developing
====
The Korg <<DW-8000>>; <<EX8000>> and <<DSS-1>> (and other early hybrid synthesisers) was created during the early days of MIDI, before things like `CC#` messages were standardised.  As a result, it uses proprietary `SysEx` commands to change parameters over MIDI. Most modern MIDI controllers use `CC#` messages instead, and very few are flexible enough to be able to send the appropriate `SysEx` messages. Those similar project uses an embedded Arduino Nano (or clone) mounted inside the synth body, which is used to intercept the MIDI IN data just before it reaches the CPU of synth. It replaces specific `CC#` messages with `SysEx` messages that the sysnthesizer understands them.
====

The project start from 5th July 2016 and based on a hack https://hackaday.io/project/12541-korg-dw-8000-midi-enhancer[Korg DW8000 midi enhancer] publication by Steve Baines https://github.com/sjbaines/Korg_DW-8000_Midi_Enhancer[and his code repo]. As His discribed His code was tested and may have been stable, but by the time November 2023, when I discovered this project on the network - I could not immediately run it on the EX8000.
It turned out to be non-working and required debugging. The pull request were added after fixing, but I did not find any activity from the project's master.
So therefore, I independently continued the path of adapting the project for Korg DSS-1, thanks to mentoring from experienced Arduino C++ coder. I achieved the first results literally a week after [the analysis differences between DW8000 vs DSS-1 of MIDI implementation charts]<<Nuances>>.

kbd:[<<Back-to-Top>>]

=== What is Arduino MIDI-translator?

Probably you know already that Arduino is a sort ofimprovement or upgrade over Synth's built-in MIDI interface circuit diagram. But what is it exactly? Let me put it this way:

imag::under controller.jpg
____

Arduino is an IC board which will allow you to take whatever MIDI controller you have, be it a keyboard or some fader box, plug it in and  tune changing of the parameter of synth…
regardless of whether your oldschool synthesizer can read `CC#` commands or not.

And for such pleasures as independence from expensive specialized controllers or the not need to be chained to a computer for software MIDI translation, you can, together with other performance equipment give a new life to old synthesizers from the 80s such as the Korg DSS-1  using Arduino and with programming skills!!
____


This Simple Arduino project to remap MIDI `CC#` messages into `SysEx` messages that Korg DSS-1 Synth expects.


The practical upshot of this is that the Synth Program parameters can be controlled by standard `CC#` messages, rather than obscure `SysEx` messages.
MIDI THRU is unaffected by the changes, as the Nano is be spliced in just before the MIDI IN reaches the CPU, AFTER the IN has been echoed back out of the THRU port.
Certain `CC#` messages are replaced with `SysEx` parameter control messages, but all other MIDI messages are passed unchanged. This means that the `SysEx` messages can still be used.
kbd:[<<Back-to-Top>>]

[#Synth part]
= Synth review

[#EX8000]
== Korg EX8000
The first my project point it was with Korg EX8000: For full project details and step by step instructions discribed at https://hackaday.io/project/12541-korg-dw-8000-midi-enhancer

[#DW8000]
== Korg DW8000

[#DSS-1]
== Korg DSS-1

During to studing and understanding the previus code i was found some differences.
There are base difference in the description of the implementation chart for DW8000 vs DSS-1:

 .the First:
====
- DW8000 parameters range from 0 to 64 (or upto 6b of SysEx length) in 7 categories:
- DSS-1 parameters vary from 0 to 127 and even upto 500 points; it increase the range categoties up to 12 (it mean SysEx length to 7b and upto 10b and more if you wish manupulating mod request parameter of synth)
Therefore, it was necessary to analyze and remake the CC Value transformation system to the additional parameters of the DSS1 regulation range that appeared.
====

 .the Second:
====
The parameter correspondence table in code for DW8000 isn't suitable for DSS-1 mapping, so I had to compeared and refer to the https://glenstegner.com/dss1/home.html[service manual Korg DSS-1] and the https://gearspace.com/board/electronic-music-instruments-and-electronic-music-production/1418944-korg-dss-1-arduino-upgrade-project.html#:~:text=DSS%2D1_SysEx%20analytical%20table[DSS-1_SysEx excel table], which is available on the https://glenstegner.com/dss1/home.html[Glen Stegner]and this site author very deeply described all the possibilities in the work of DSS-1. Therefore, I also pay tribute and respect to Glen Stegner in his preparation of the site.
Including there are certain nuances when implementing Sisex commands, which I left for later and placed them in the last section <<nuancesand and troubleshooting>>:

image:IMAGES/COM_IMG/GlenSiegner.png[GlenStegner]

====

 .The Third:
====
- the parameters `DDL 1&2 Time` have control range from *0~500*, and it was necessary to create additional processing to transform the CC# range (0-127) into the expected one, implement 9-byte SysEx distribution over MSB LSB nibbles.
====

 .The Four:
====
- the parameters `DDL 1&2 Time` have control range from *0~500*, and it was necessary to create additional processing to transform the CC# range (0-127) into the expected one, implement 9-byte SysEx distribution over MSB LSB nibbles.
====
On this basis, a new table of correspondence between DDS-1 parameters and application of parameters to CC# control messages from the controller.

kbd:[<<Back-to-Top>>]

[#Controller part]
= Controller part review

[#Nucleus]
== SSL Nucleus
:imagesdir: IMAGES/Controllers/SSL Nucleus/
.example: MCU & XT Projections
|===
|image:projection_MCU.svg[Projection MCU,470,380] |image:projection_XT.svg[Projection XT,260,380]
2+|image:SSL_Nucleus_Mk2.svg[SSL_Nucleus_Mk2,700,350]
|===

[#JP800]
== Roland JP8000

kbd:[<<Back-to-Top>>]

[#code discribe]
= CODE Discribtion

kbd:[<<Back-to-Top>>]

[#MIDI Table]
= MIDI implementation charts

kbd:[<<Back-to-Top>>]

[#nuances and troubleshooting]
= Nuances and troubleshooting
on Glen Stegner's website there is a section on https://glenstegner.com/dss1/home.html[Tips and Trics], which describes very interesting things that are implemented by the manufacturer, but which are evaluated and interpretating by the musicians in two ways.
I would say - based on their preferences of each performer at Korg DSS.
  .here is one of them:

- parameters `OSC 1 Level` and `OSC 2 Level`: which are marked on the operating system of the synthesizer as *[F14]* as `OSC Mix ratio` or *X-fader* with manipulation by one fade from the synth surface.
This parameter is also described in the Program Parameter table [3] and has a image:IMAGES/LSB_MSB data format.jpeg

[#NOTE]: _Must be set for both oscilator so that OSC1 + OSC2 = 100_


which is not mandatory for the performing musician. because you can manage the parameters separately via Sysex:

 - `Osc 1 level: [F0 42 30 0B 41 00 xx F7]`
 - `Osc 2 level: [F0 42 30 0B 41 01 xx F7]`

or 2nd way:

 - `Osc Mix ratio: [F0 42 30 0B 41 00 xx 00 yy F7]`

My original code version is implemented as 2 (see Unit_3)

[example%collapsible]
[source,cpp]
----
// Scaling SyxEx_10 leight of OSC mix ratio using by one CC# source:
void sendParam_10(byte channel, byte paramNumber, byte paramValue7Bit) { // Unit_3
  const int sysexLen = 10;
  static byte sysexData[sysexLen] = {
    0xF0, // 0 SOX
    0x42, // 1 Manufacturer ID: 42, Korg
    0x30, // 2 Channel 1
    0x0B, // 3 Device ID: 0b, DSS-1
    0x41, // 4 Message: 41, Parameter change (it not the parameter DUMP)
    0x00, // 5 Parameter number (1-st param witch we going to change)
    0x00, // 6 Parameter master value
    0x00, // 7 Parameter number (be as slave)
    0x00, // 8 Parameter slave value
    0xF7  // 9 EOX
    };
    paramValue7Bit &= 0x7f;
    int paramValueScaled;
    switch (paramNumber) { // so here we rescale to fit to rang:
        case 0x00: // [F14] paramNumber 0 OSC1 level Mix ratio (master)
	case 0x01: // [F14] paramNumber 1 OSC2 level Mix ratio (slave)
	paramValueScaled = paramValue7Bit*203/256; break;
    default:
    return;	// unknown parameter - ignore
   }
    sysexData[2] = 0x30 | ((channel - 1) & 0x0f);// Set channel number
    sysexData[5] = paramNumber; // master must be (Mster+Slave) == 100%:
    sysexData[6] = paramValueScaled & 0x7f; // master value
    sysexData[7] = (paramNumber +1); // slave
    sysexData[8] = (100 - paramValueScaled) & 0x7f; // slave value
    MIDI.sendSysEx(sysexLen, sysexData, true);
}
----

====
And this may be a controversial decision, since according to the reasoning on the https://glenstegner.com/dss1/home.html[Glen website]:
- he prefers an independent control option for the `OSC 1&2` parameter with the ability to raise the level of both oscillators up to 100%, while training the powerful OUTPUT from the synthesizer.
====
My reason was to create authenticity to
- the "DSS like" control method and
- the ability to save the fader control on the SSL Nucleus controller. Plus,
- the argument for *X-fader* control is that it is possible to achieve overload at the DAC output when playing particularly loud waves with distortion.
====
How to avoid this and whether this is considered an artistic decision by the performer is up to everyone to decide for themselves!
image:IMAGES/LSB_MSB data format.jpeg

kbd:[<<Back-to-Top>>]

